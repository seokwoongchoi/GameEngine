#pragma once
struct OceanParameter
{
	// Must be power of 2.
	int dmap_dim;
	// Typical value is 1000 ~ 2000
	float patch_length;

	// Adjust the time interval for simulation.
	float time_scale;
	// Amplitude for transverse wave. Around 1.0
	float wave_amplitude;
	// Wind direction. Normalization not required.
	D3DXVECTOR2 wind_dir;
	// Around 100 ~ 1000
	float wind_speed;
	// This value damps out the waves against the wind direction.
	// Smaller value means higher wind dependency.
	float wind_dependency;
	// The amplitude for longitudinal wave. Must be positive.
	float choppy_scale;
};


// Quad-tree LOD, 0 to 9 (1x1 ~ 512x512) 


class OceanSimulator
{
public:
	OceanSimulator();
	~OceanSimulator();

	// Update ocean wave when tick arrives.
	void updateDisplacementMap(float time);
	void initHeightMap(OceanParameter& params, D3DXVECTOR2* out_h0, float* out_omega);
	void CreateBufferAndUAV(void* data, uint byteWidth, uint byteStride,
		ID3D11Buffer** ppBuffer, ID3D11UnorderedAccessView** ppUAV, ID3D11ShaderResourceView** ppSRV);
	void CreateTextureAndViews(uint width, uint height, DXGI_FORMAT format,
		ID3D11Texture2D** ppTex, ID3D11ShaderResourceView** ppSRV, ID3D11RenderTargetView** ppRTV);
	
	const OceanParameter& getParameters();


	float Gauss();
	float Phillips(Vector2 K, Vector2 W, float v, float a, float dir_depend);
	// Texture access
	ID3D11ShaderResourceView* getD3D11DisplacementMap();
	ID3D11ShaderResourceView* getD3D11GradientMap();

	/*void ApplyResources();
	ID3DX11EffectShaderResourceVariable* sDisplacement;
	ID3DX11EffectShaderResourceVariable* sPerlin;
	ID3DX11EffectShaderResourceVariable* sGradient;
	ID3DX11EffectShaderResourceVariable* sFresnel;
	ID3DX11EffectShaderResourceVariable* sCube;*/




private:
	
	class Shader* csShader;
	class Shader* shader;
	OceanParameter params;



private:
	// Displacement map
	ID3D11Texture2D* m_pDisplacementMap = NULL;	// (RGBA32F)
	ID3D11ShaderResourceView* m_pDisplacementSRV = NULL;
	ID3D11RenderTargetView* m_pDisplacementRTV = NULL;

	// Gradient field
	ID3D11Texture2D* m_pGradientMap = NULL;			// (RGBA16F)
	ID3D11ShaderResourceView* m_pGradientSRV = NULL;
	ID3D11RenderTargetView* m_pGradientRTV = NULL;

	// Samplers
	ID3D11SamplerState* m_pPointSamplerState;
private:
	// ----------------------------------- CS simulation data ---------------------------------

	// Initial height field H(0) generated by Phillips spectrum & Gauss distribution.
	ID3D11Buffer* m_pBuffer_Float2_H0 = NULL;
	ID3D11UnorderedAccessView* m_pUAV_H0 = NULL;
	ID3D11ShaderResourceView* m_pSRV_H0 = NULL;

	// Angular frequency
	ID3D11Buffer* m_pBuffer_Float_Omega = NULL;
	ID3D11UnorderedAccessView* m_pUAV_Omega = NULL;
	ID3D11ShaderResourceView* m_pSRV_Omega = NULL;

	// Height field H(t), choppy field Dx(t) and Dy(t) in frequency domain, updated each frame.
	ID3D11Buffer* m_pBuffer_Float2_Ht = NULL;
	ID3D11UnorderedAccessView* m_pUAV_Ht = NULL;
	ID3D11ShaderResourceView* m_pSRV_Ht = NULL;

	// Height & choppy buffer in the space domain, corresponding to H(t), Dx(t) and Dy(t)
	ID3D11Buffer* m_pBuffer_Float_Dxyz = NULL;
	ID3D11UnorderedAccessView* m_pUAV_Dxyz = NULL;
	ID3D11ShaderResourceView* m_pSRV_Dxyz = NULL;
	
	
	VertexBuffer* vertexBuffer;
	IndexBuffer* indexBuffer;
	//vector<Vertex> vertices;
private:
	class OceanFFT* FFT;
	struct CB_Immutable
	{
		uint actualDim;
		uint inputWidth;
		uint outputWidth;
		uint outputHeight;
		uint dtxOffset;
		uint dtyOffset;
		float Padding[2];
		
	};
	CB_Immutable immutableCB;

	ConstantBuffer* immutableBuffer;
	ID3DX11EffectConstantBuffer* sImmutableBuffer;
	ID3DX11EffectConstantBuffer* sImmutableBufferCS;

	struct CB_PerFrame
	{
		float Time;
		float ChoppyScale;
		float GridLen;
		float Padding;
	};
	CB_PerFrame perframeCB;

	ConstantBuffer* perframeBuffer;
	ID3DX11EffectConstantBuffer* sPerframeBuffer;
	ID3DX11EffectConstantBuffer* sPerframeBufferCS;


	// FFT wrap-up
	//CSFFT512x512_Plan m_fft_plan;
};

